#' @name gl.grm.network
#' @title Represents a genomic relationship matrix (GRM) as a network
#' @description 
#' This script takes a G matrix generated by \code{\link{gl.grm}} and represents the 
#' relationship among the specimens as a network diagram. In order to use this 
#' script, a decision is required on a threshold for relatedness to be 
#' represented as link in the network, and on the layout used to create the diagram.
#'
#' 
#' @param G A genomic relationship matrix (GRM) generated by \code{\link{gl.grm}}[required]
#' @param x A genlight object from which the G matrix was generated [required]
#' @param method One of fr, kk or drl [default fr]
#' @param node.size Size of the symbols for the network nodes [default 14]
#' @param node.label TRUE to display node labels [default TRUE]
#' @param node.label.size Size of the node labels [default 4]
#' @param node.label.color Color of the text of the node labels [default "black"]
#' @param alpha Upper threshold to determine which links between nodes to display [default 0.995]
#' @param title Title for the plot [default "Network based on genomic relationship matrix"]
#' @param palette_discrete A discrete palette for the color of the populations
#'  [default discrete_palette]
#' @param verbose Verbosity: 0, silent or fatal errors; 1, begin and end; 2,
#'  progress log ; 3, progress and results summary; 5, full report 
#'  [default 2 or as specified using gl.set.verbosity]
#'
#' @details 
#' The threshold for relatedness to be represented as a link in the network is 
#' specified as a quantile. Those relatedness measures above the quantile are
#' plotted as links, those below the quantile are not. Often you are looking
#'  for relatedness outliers in comparison with the overall relatedness among 
#'  individuals, so a very conservative quantile is used (e.g. 0.004), but 
#'  ultimately, this decision is made as a matter of trial and error. One way to
#'   approach this trial and error is to try to achieve a sparse set of links 
#'   between unrelated 'background' individuals so that the stronger links are 
#'   preferentially shown.
#' 
#' There are several layouts from which to choose. The most popular are given as
#'  options in this script.
#' 
#' fr -- Fruchterman, T.M.J. and Reingold, E.M. (1991). Graph Drawing by Force-directed Placement. Software -- Practice and Experience 21:1129-1164.
#' kk -- Kamada, T. and Kawai, S.: An Algorithm for Drawing General Undirected Graphs. Information Processing Letters 31:7-15, 1989. 
#' drl -- Martin, S., Brown, W.M., Klavans, R., Boyack, K.W., DrL: Distributed Recursive (Graph) Layout. SAND Reports 2936:1-10, 2008. 
#' 
#' colors of node symbols are those of the rainbow.
#'
#' @return A network plot showing relatedness between individuals 
#' @author Arthur Georges -- Post to \url{https://groups.google.com/d/forum/dartr}
#' @examples
#' gl_test <- bandicoot.gl[1:20,]
#' G_out <- gl.grm(gl_test)
#' gl.grm.network(G_out,gl_test)  
#'
#' @seealso \code{\link{gl.grm}}
#' @family inbreeding functions
#' @importFrom grDevices rgb
#' @importFrom graphics legend plot
#' @export

gl.grm.network <- function(G, 
                           x,
                           method = "fr", 
                           node.size = 6, 
                           node.label = TRUE, 
                           node.label.size = 2, 
                           node.label.color = "black",
                           alpha = 0.004, 
                           title = "Network based on genomic relationship matrix", 
                           palette_discrete = discrete_palette,
                           verbose = NULL){
  
  # SET VERBOSITY
  verbose <- gl.check.verbosity(verbose)
  
  # FLAG SCRIPT START
  funname <- match.call()[[1]]
  utils.flag.start(f=funname,build="Jackson",v=verbose)
  
  # CHECK DATATYPE 
  datatype <- utils.check.datatype(x)
  
  # FUNCTION SPECIFIC ERROR CHECKING
  # check if package is installed
  pkg <- "igraph"
  if (!(requireNamespace(pkg, quietly = TRUE))) {
    stop(error("Package",pkg," needed for this function to work. Please install it.")) 
         }

  if (!(method=="fr" || method=="kk" || method=="drl")) {
    cat(warn("Warning: Layout method must be one of fr, or kk, or drl, set to fr\n"))
    method <- "fr"
  }
  
  # DO THE JOB    
  
  G[upper.tri(G,diag = T)]  <- NA
  links <- as.data.frame(as.table(G))
  links <- links[which(!is.na(links$Freq)),]

  colnames(links) <- c("from","to","weight")
  
  nodes <- data.frame(cbind(x$ind.names, as.character(pop(x))))
  colnames(nodes) <- c("name","pop")
  
  network <- igraph::graph_from_data_frame(d=links, vertices=nodes, directed=FALSE)

  q <- stats::quantile(links$weight, p = 1-alpha)
  network.FS <- igraph::delete_edges(network, igraph::E(network)[links$weight < q ])
  
  # layout.auto	Choose an appropriate graph layout algorithm automatically
  # layout.bipartite	Simple two-row layout for bipartite graphs
  # layout.circle	Deprecated layout functions
  # layout.davidson.harel	The Davidson-Harel layout algorithm
  # layout.drl	The DrL graph layout generator
  # layout.fruchterman.reingold	Deprecated layout functions
  # layout.fruchterman.reingold.grid	Grid Fruchterman-Reingold layout, this was removed from igraph
  # layout.gem	The GEM layout algorithm
  # layout.graphopt	The graphopt layout algorithm
  # layout.grid	Simple grid layout
  # layout.grid.3d	Simple grid layout
  # layout.kamada.kawai	Deprecated layout functions
  # layout.lgl	Deprecated layout functions
  # layout.mds	Graph layout by multidimensional scaling
  # layout.merge	Merging graph layouts
  # layout.norm	Normalize coordinates for plotting graphs
  # layout.random	Deprecated layout functions
  # layout.reingold.tilford	Deprecated layout functions
  # layout.sphere	Deprecated layout functions
  # layout.spring	Spring layout, this was removed from igraph
  # layout.star	Generate coordinates to place the vertices of a graph in a star-shape
  # layout.sugiyama	The Sugiyama graph layout generator
  # layout.svd	SVD layout, this was removed from igraph
  # layout_	Graph layouts
  # layout_as_bipartite	Simple two-row layout for bipartite graphs
  # layout_as_star	Generate coordinates to place the vertices of a graph in a star-shape
  # layout_as_tree	The Reingold-Tilford graph layout algorithm
  # layout_components	Merging graph layouts
  # layout_in_circle	Graph layout with vertices on a circle.
  # layout_nicely	Choose an appropriate graph layout algorithm automatically
  # layout_on_grid	Simple grid layout
  # layout_on_sphere	Graph layout with vertices on the surface of a sphere
  # layout_randomly	Randomly place vertices on a plane or in 3d space
  # layout_with_dh	The Davidson-Harel layout algorithm
  # layout_with_drl	The DrL graph layout generator
  # layout_with_fr	The Fruchterman-Reingold layout algorithm
  # layout_with_gem	The GEM layout algorithm
  # layout_with_graphopt	The graphopt layout algorithm
  # layout_with_kk	The Kamada-Kawai layout algorithm
  # layout_with_lgl	Large Graph Layout
  # layout_with_mds	Graph layout by multidimensional scaling
  # layout_with_sugiyama	The Sugiyama graph layout generator
  
  if (method=="fr"){
    layout.name <- "Fruchterman-Reingold layout"
    plotcord <- data.frame(layout.fruchterman.reingold(network.FS))
  }
  
  if (method=="kk"){
    layout.name <- "Kamada-Kawai layout"
    plotcord <- data.frame(layout.kamada.kawaiv(network.FS))
  }
  
  if (method=="drl"){
    layout.name <- "DrL Graph layout"
    plotcord <- data.frame(layout_with_drl(network.FS))
  }
  
  #get the nod coordinates
  colnames(plotcord) = c("X1","X2")
  #get edges, which are pairs of node IDs
  edgelist <- get.edgelist(network.FS,names = F)
  #convert to a four column edge data frame with source and destination coordinates
  edges <- data.frame(plotcord[edgelist[,1],], plotcord[edgelist[,2],])
  colnames(edges) <- c("X1","Y1","X2","Y2")
  
  if (node.label) {
    label.node <- igraph::V(network.FS)$name
  } else {
    label.node <- NA
  }
  
  # assigning colors to populations
  colors_pop_temp <- palette_discrete(length(levels(pop(x))))
  names(colors_pop_temp) <- as.character(levels(x$pop))
  cols_pops <- as.data.frame(cbind(names(colors_pop_temp),colors_pop_temp))
  colnames(cols_pops) <- c("pop","colour")
  df_pops <- as.data.frame(x$pop)
  colnames(df_pops) <- c("pop")
  cols_pops <- merge(df_pops,cols_pops,by="pop")
  
  title <- paste(title,"\n[",layout.name,"]")
  
  p1 <- ggplot() + 
    geom_segment(data=edges,aes(x=X1, y=Y1, xend = X2, yend = Y2), size = 1, colour="black",show.legend=FALSE)+    
    geom_point(data=plotcord,aes(x=X1, y=X2,colour=cols_pops$colour),size=node.size) +
    geom_text(data=plotcord,aes(x=X1, y=X2,label = label.node),size=node.label.size,show.legend=FALSE,colour=node.label.color) +
    # scale_colour_manual(labels=unique(cols_pops$pop),values = unique(cols_pops$colour),name="Populations")+
    coord_fixed(ratio = 1) +
    theme_void()+
    ggtitle(title) +
    theme(plot.title = element_text(hjust = 0.5, face="bold"),legend.position="bottom")
  
  print(p1)

# FLAG SCRIPT END

if (verbose >= 1) {
  cat(report("\nCompleted:", funname, "\n\n"))
}

# RETURN
invisible(p1)
    
}  
