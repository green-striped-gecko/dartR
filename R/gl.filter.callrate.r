#' @name gl.filter.callrate
#'
#' @title Filter loci or individuals in a genlight \{adegenet\} object based on call rate
#'
#' @description 
#' SNP datasets generated by DArT have missing values primarily arising from failure
#' to call a SNP because of a mutation at one or both of the restriction enzyme 
#' recognition sites. Tag Presence/Absence datasets (SilicoDArT) have missing values 
#' where it is not possible to determine reliably if there the sequence tag can be 
#' called at a particular locus. This function will filtered out loci or individuals 
#' based on call rate. 
#'
#' @param x Name of the genlight object containing the SNP or presence/absence
#'  (SilicoDArT) data [required].
#' @param method "loc" to specify that loci are to be filtered, "ind" to specify that specimens are to be filtered, "pop"
#' to remove loci that fail to meet the specified threshold in any one population [default "loc"].
#' @param threshold Threshold value below which loci will be removed [default 0.95].
#' @param plot Specify if histograms of call rate, before and after, are to be produced [default TRUE].
#' @param bins Number of bins to display in histograms [default 50].
#' @param mono.rm Remove monomorphic loci after analysis is complete [default FALSE].
#' @param recalc Recalculate the locus metadata statistics if any individuals are deleted in the filtering [default FALSE].
#' @param recursive Repeatedly filter individuals on call rate, each time removing monomorphic loci. Only applies if method="ind" and mono.rm=TRUE [default FALSE]
#' @param plot_theme Theme for the plot. See Details for options [default theme_dartR()].
#' @param plot_colours List of two color names for the borders and fill of the
#'  plots [default two_colors].
#' @param verbose Verbosity: 0, silent or fatal errors; 1, begin and end; 2, progress log ; 3, progress and results summary; 5, full report [default NULL, unless specified using gl.set.verbosity].
#'
#' @details The function \code{\link{gl.report.callrate}} will report summary of 
#' Call Rate for loci or individuals
#'  
#'\strong{ Function's output }
#'
#'  The minimum, maximum, mean and a tabulation of call rate quantiles against
#'  thresholds are provided. Output also includes a boxplot and a
#'  histogram before and after the filtering.
#'
#'  Plots and table are saved to the temporal directory (tempdir) and can be accessed
#'  with the function \code{\link{gl.print.reports}} and listed with the function
#'  \code{\link{gl.list.reports}}. Note that they can be accessed only in the 
#'  current R session because tempdir is cleared each time that the R session is closed.
#'   
#'  Examples of other themes that can be used can be consulted in \itemize{
#'  \item \url{https://ggplot2.tidyverse.org/reference/ggtheme.html} and \item
#'  \url{https://yutannihilation.github.io/allYourFigureAreBelongToUs/ggthemes/}
#'  }
#'
#' @return The reduced genlight or genind object
#'
#' @author Arthur Georges and Bernd Gruber (Post to \url{https://groups.google.com/d/forum/dartr})
#'
#' @examples
#' # SNP data
#'   result <- gl.filter.callrate(testset.gl, method="loc", threshold=0.95, verbose=3)
#'   result <- gl.filter.callrate(testset.gl, method="ind", threshold=0.8, verbose=3)
#' # Tag P/A data
#'   result <- gl.filter.callrate(testset.gs, method="loc", threshold=0.95, verbose=3)
#'   result <- gl.filter.callrate(testset.gs, method="ind", threshold=0.8, verbose=3)
#'
#' @seealso \code{\link{gl.report.callrate}}, \code{\link{gl.list.reports}},
#'  \code{\link{gl.print.reports}}
#'  
#' @family filter functions
#'
#' @import patchwork
#'
#' @export
#'  

 gl.filter.callrate <- function(x, 
                                method = "loc", 
                                threshold = 0.95,
                                mono.rm = FALSE, 
                                recalc = FALSE, 
                                recursive = FALSE,
                                plot = TRUE, 
                                bins = 50,
                                plot_theme = theme_dartR(), 
                                plot_colours = two_colors, 
                                verbose = NULL) {
  
   
   # TRAP COMMAND
   
   funname <- match.call()[[1]]
   
   # SET VERBOSITY
   
   verbose <- gl.check.verbosity(verbose)
   
   # CHECKS DATATYPE 
   
   datatype <- utils.check.datatype(x)
   
   hold <- x

  # Check monomorphs have been removed up to date
  if (x@other$loc.metrics.flags$monomorphs == FALSE){
    if (verbose >= 2){
      cat(warn("  Warning: Dataset contains monomorphic loci which will be included in the Call Rate calculations for the filtering\n"))
    }  
  }
  
  # Check call rate up to date
    if (x@other$loc.metrics.flags$CallRate == FALSE){
      if (verbose >= 2){
        cat(report("  Recalculating Call Rate\n"))
      }  
        x <- utils.recalc.callrate(x,verbose=0)
    }
   
  # Suppress plotting on verbose == 0
   if(verbose==0){
     plot=FALSE
     }
  
# FUNCTION SPECIFIC ERROR CHECKING

   if (method != "ind" & method != "loc" & method != "pop") {
     cat(warn("    Warning: method must be either \"loc\" or \"ind\" or \"pop\", set to \"loc\" \n"))
     method <- "loc"
   }

   if (threshold < 0 | threshold > 1){
     cat(warn("    Warning: threshold must be an integer between 0 and 1, set to 0.95\n"))
     threshold <- 0.95
   }

# DO THE JOB
    
   ########### FOR METHOD BASED ON LOCUS
   
  if( method == "loc" ) {
    # Determine starting number of loci and individuals
    if (verbose >= 2) {
      cat(report("  Removing loci based on Call Rate, threshold =",threshold,"\n"))
      }
    n0 <- nLoc(x)
    if (verbose >= 3) {
      cat(report("Initial no. of loci =", n0, "\n"))
      }

    # Remove loci with NA count <= 1-threshold
      x2 <- x[ ,glNA(x,alleleAsUnit=FALSE)<=((1-threshold)*nInd(x))]
      x2@other$loc.metrics <- x@other$loc.metrics[glNA(x,alleleAsUnit=FALSE)<=((1-threshold)*nInd(x)),]
      
      if (verbose > 2) {
        cat (report("  No. of loci deleted =", (n0-nLoc(x2)),"\n"))
        }
      
    # Plot a histogram of Call Rate
      
      if(all(x@ploidy==2)){
        title <- "Call Rate by locus\n[pre-filtering, SNP dataset]"
      } else {
        title <- "Call Rate by locus\n[pre-filtering, Tag presence/absence dataset]"
      }  
      
    
      
      if (plot) {
        # prefiltering histogram 
        callrate_pre <- data.frame(x@other$loc.metrics$CallRate)
        colnames(callrate_pre) <- "callrate"
        
        p1 <-  ggplot(callrate_pre, aes(x = callrate)) + 
          geom_histogram(bins = bins, color = plot_colours[1],fill = plot_colours[2]) + 
          coord_cartesian(xlim = c(min(x@other$loc.metrics$CallRate),1)) + 
          xlab("Call rate") + 
          ylab("Count") + 
          ggtitle(title) +
          plot_theme
        
        # after filtering histogram 
        callrate_post <- data.frame(x2@other$loc.metrics$CallRate)
        colnames(callrate_post) <- "callrate"
        
        p2 <-  ggplot(callrate_post, aes(x = callrate)) + 
          geom_histogram(bins = bins, color = plot_colours[1],fill = plot_colours[2]) + 
          coord_cartesian(xlim = c(min(x2@other$loc.metrics$CallRate),1)) + 
          xlab("Call rate") + 
          ylab("Count") + 
          ggtitle("[post-filtering]") +
          plot_theme
        
      }  
      if (mono.rm) {
        # Remove monomorphic loci  
        x2 <- gl.filter.monomorphs(x2,verbose=0)
      }
      if (recalc) {
        # Recalculate all metrics, including Call Rate (flags reset in utils scripts)
        x2 <- gl.recalc.metrics(x2, verbose=verbose)
      } else {
        # Reset the flags as FALSE for all metrics except Call Rate (dealt with elsewhere)
        x2@other$loc.metrics.flags$AvgPIC <- FALSE
        x2@other$loc.metrics.flags$OneRatioRef <- FALSE
        x2@other$loc.metrics.flags$OneRatioSnp <- FALSE
        x2@other$loc.metrics.flags$PICRef <- FALSE
        x2@other$loc.metrics.flags$PICSnp <- FALSE
        x2@other$loc.metrics.flags$maf <- FALSE
        x2@other$loc.metrics.flags$FreqHets <- FALSE
        x2@other$loc.metrics.flags$FreqHomRef <- FALSE
        x2@other$loc.metrics.flags$FreqHomSnp <- FALSE
      }
  }
  
   ########### FOR METHOD BASED ON INDIVIDUAL
   
  if ( method == "ind" ) {
    
    # Determine starting number of loci and individuals
    if (verbose > 1) {
      cat(report("  Removing individuals based on Call Rate, threshold =",threshold,"\n"))
      }
      n0 <- nInd(x)
    if (verbose > 2) {
      cat(report("Initial no. of individuals =", n0, "\n"))
      }
      
    # Calculate the individual call rate
      ind.call.rate <- 1 - rowSums(is.na(as.matrix(x)))/nLoc(x)
    # Store the initial call rate profile
      hold2 <- ind.call.rate
    # Check that there are some individuals left
      if (sum(ind.call.rate >= threshold) == 0){
        stop(error(paste("Maximum individual call rate =",round(max(ind.call.rate),3),". Nominated threshold of",threshold,"too stringent.\n No individuals remain.\n")))
      }
      
      if (!recursive) {
    # Extract those individuals with a call rate greater or equal to the threshold
      x2 <- x[ind.call.rate >= threshold,]

    # for some reason that eludes me, this also (appropriately) filters the latlons and the covariates, but see above for locus filtering
        if (verbose > 2){
          cat (report("Filtering a genlight object\n  No. of individuals deleted =", (n0-nInd(x2)), "\nIndividuals retained =", nInd(x2),"\n"))
               }
      
    # Report individuals that are excluded on call rate
      if (any(ind.call.rate <= threshold)) {
        x3 <- x[ind.call.rate <= threshold,]
        if (length(x3) > 0) {
          if (verbose >= 2) {
            cat(report("  No. of individuals deleted (CallRate <= ",threshold,":\n"))
            cat(report(paste0(indNames(x3),"[",as.character(pop(x3)),"],")))
          }  

              if (mono.rm) {
              # Remove monomorphic loci  
                x2 <- gl.filter.monomorphs(x2,verbose=0)
              }
              if (recalc) {
              # Recalculate all metrics, including Call Rate (flags reset in utils scripts)
                x2 <- gl.recalc.metrics(x2, verbose=verbose)
              } else {
              # Reset the flags as FALSE for all metrics except Call Rate (dealt with elsewhere)
                x2@other$loc.metrics.flags$AvgPIC <- FALSE
                x2@other$loc.metrics.flags$OneRatioRef <- FALSE
                x2@other$loc.metrics.flags$OneRatioSnp <- FALSE
                x2@other$loc.metrics.flags$PICRef <- FALSE
                x2@other$loc.metrics.flags$PICSnp <- FALSE
                x2@other$loc.metrics.flags$maf <- FALSE
                x2@other$loc.metrics.flags$FreqHets <- FALSE
                x2@other$loc.metrics.flags$FreqHomRef <- FALSE
                x2@other$loc.metrics.flags$FreqHomSnp <- FALSE
              }
        }
      }  
    # Recalculate the callrate
      ind.call.rate <- 1 - rowSums(is.na(as.matrix(x2)))/nLoc(x2)
      # cat(min(ind.call.rate),"\n")
    
    } else { # If recursive
      
      # Recursively remove individuals
      cat(report("Recursively removing individuals with call rate <",threshold,", recalculating Call Rate after deleting monomorphs, and repeating until final Call Rate is >=",threshold,"\n"))
      for (i in 1:10) {
        # Recalculate the callrate
        ind.call.rate <- 1 - rowSums(is.na(as.matrix(x)))/nLoc(x)
        # Extract those individuals with a call rate greater or equal to the threshold
        x2 <- x[ind.call.rate >= threshold,]
        
        if (nInd(x2) == nInd(x)){
          break
          }
        
        # for some reason that eludes me, this also (appropriately) filters the latlons and the covariates, but see above for locus filtering
        if (verbose > 2){
          cat(report("ITERATION",i,"\n  No. of individuals deleted =", (n0-nInd(x2)), "\n  No. of individuals retained =", nInd(x2),"\n"))
          }
        
        # Report individuals that are excluded on call rate
        if (any(ind.call.rate <= threshold)) {
          x3 <- x[ind.call.rate <= threshold,]
          if (length(x3) > 0) {
            if (verbose >= 3) {
              cat(report("  List of individuals deleted (CallRate <= ",threshold,":\n"))
              cat(report(paste0(indNames(x3),"[",as.character(pop(x3)),"],")))
              cat("\n")
            }  
            if (mono.rm) {
              # Remove monomorphic loci  
              x2 <- gl.filter.monomorphs(x2,verbose=0)
            }
            if (recalc) {
              # Recalculate all metrics, including Call Rate (flags reset in utils scripts)
              x2 <- gl.recalc.metrics(x2, verbose=verbose)
            } else {
              # Reset the flags as FALSE for all metrics except Call Rate (dealt with elsewhere)
              x2@other$loc.metrics.flags$AvgPIC <- FALSE
              x2@other$loc.metrics.flags$OneRatioRef <- FALSE
              x2@other$loc.metrics.flags$OneRatioSnp <- FALSE
              x2@other$loc.metrics.flags$PICRef <- FALSE
              x2@other$loc.metrics.flags$PICSnp <- FALSE
              x2@other$loc.metrics.flags$maf <- FALSE
              x2@other$loc.metrics.flags$FreqHets <- FALSE
              x2@other$loc.metrics.flags$FreqHomRef <- FALSE
              x2@other$loc.metrics.flags$FreqHomSnp <- FALSE
            }
          }
        } 
        
        x <- x2

      } 
    }  
      
      # Plot a histogram of Call Rate

      if(all(x@ploidy==2)){
        title <- "Call Rate by individual\n[pre-filtering, SNP dataset]"
      } else {
        title <- "Call Rate by individual\n[pre-filtering, Tag presence/absence dataset]"
      }  
  
      if (plot) {
        
        # prefiltering histogram 
        callrate_pre <- data.frame(hold2)
        colnames(callrate_pre) <- "callrate"
        
        p1 <-  ggplot(callrate_pre, aes(x = callrate)) + 
          geom_histogram(bins = bins, color = plot_colours[1],fill = plot_colours[2]) + 
          coord_cartesian(xlim = c(min(hold2),1)) + 
          xlab("Call rate") + 
          ylab("Count") + 
          ggtitle(title) +
          plot_theme

        # after filtering histogram 
        callrate_post <- data.frame(ind.call.rate)
        colnames(callrate_post) <- "callrate"
        
        p2 <-  ggplot(callrate_post, aes(x = callrate)) + 
          geom_histogram(bins = bins, color = plot_colours[1],fill = plot_colours[2]) + 
          coord_cartesian(xlim = c(min(ind.call.rate),1)) + 
          xlab("Call rate") + 
          ylab("Count") + 
          ggtitle("[post-filtering]") +
          plot_theme

      }
  }
  
   ########### FOR METHOD BASED ON POPULATIONS
   
  if (method == 'pop'){
    
    if (verbose >= 2) {
      cat(report("  Removing loci based on Call Rate by population, Call rate must be equal to or exceed threshold =",threshold,"in all populations\n"))
    }
    
    pops <- seppop(x) 
    ll <- lapply(pops, function(x) locNames(gl.filter.callrate(x, method = "loc", threshold = threshold, verbose = 0)))
    locall <- Reduce(intersect, ll)
    index <- which(locNames(x) %in% locall)
    x <- x[ , locall]
    x@other$loc.metrics <- x@other$loc.metrics[locall,]
    
    x <- utils.recalc.callrate(x,verbose = 0)

    # Plot a histogram of Call Rate
    
    if(all(x@ploidy==2)){
      title <- "Call Rate by population\n[pre-filtering by population, SNP dataset]"
    } else {
      title <- "Call Rate by population\n[pre-filtering by population, Tag presence/absence dataset]"
    }  
    
    if (plot) {
      
      # prefiltering histogram 
      callrate_pre <- data.frame(hold@other$loc.metrics$CallRate)
      colnames(callrate_pre) <- "callrate"
      
      p1 <-  ggplot(callrate_pre, aes(x = callrate)) + 
        geom_histogram(bins = bins, color = plot_colours[1],fill = plot_colours[2]) + 
        coord_cartesian(xlim = c(min(hold@other$loc.metrics$CallRate),1)) + 
        xlab("Call rate") + 
        ylab("Count") + 
        ggtitle(title) +
        plot_theme
      
      # after filtering histogram 
      callrate_post <- data.frame(x@other$loc.metrics$CallRate)
      colnames(callrate_post) <- "callrate"
      
      p2 <-  ggplot(callrate_post, aes(x = callrate)) + 
        geom_histogram(bins = bins, color = plot_colours[1],fill = plot_colours[2]) + 
        coord_cartesian(xlim = c(min(x@other$loc.metrics$CallRate),1)) + 
        xlab("Call rate") + 
        ylab("Count") + 
        ggtitle("[post-filtering]") +
        plot_theme
  
    }
    
    x2 <- x
    if (mono.rm) {
      # Remove monomorphic loci  
      x2 <- gl.filter.monomorphs(x2,verbose=0)
    }
    if (recalc) {
      # Recalculate all metrics, including Call Rate (flags reset in utils scripts)
      x2 <- gl.recalc.metrics(x2, verbose=verbose)
    } else {
      # Reset the flags as FALSE for all metrics except Call Rate (dealt with elsewhere)
      x2@other$loc.metrics.flags$AvgPIC <- FALSE
      x2@other$loc.metrics.flags$OneRatioRef <- FALSE
      x2@other$loc.metrics.flags$OneRatioSnp <- FALSE
      x2@other$loc.metrics.flags$PICRef <- FALSE
      x2@other$loc.metrics.flags$PICSnp <- FALSE
      x2@other$loc.metrics.flags$maf <- FALSE
      x2@other$loc.metrics.flags$FreqHets <- FALSE
      x2@other$loc.metrics.flags$FreqHomRef <- FALSE
      x2@other$loc.metrics.flags$FreqHomSnp <- FALSE
    }
  }

# REPORT A SUMMARY
   if (verbose > 2) {
     cat("Summary of filtered dataset\n")
     if (method=='pop'){
       cat(paste("  Call Rate in any one population >",threshold,"\n"))
     } else if (method=='ind'){
       cat(paste("  Call Rate for individuals >",threshold,"\n"))
     } else {
       cat(paste("  Call Rate for loci >",threshold,"\n"))
     }
     cat(paste("  Original No. of loci :",nLoc(hold),"\n"))
     cat(paste("  Original No. of individuals:", nInd(hold),"\n"))
     cat(paste("  No. of loci retained:",nLoc(x2),"\n"))
     cat(paste("  No. of individuals retained:", nInd(x2),"\n"))
     cat(paste("  No. of populations: ", length(levels(factor(pop(x2)))),"\n"))
   }
   
   if (verbose >= 2) {
     if (method == "ind"){
       if (!recalc) {
         cat(important("  \nNOTE: Locus metrics not recalculated\n"))
       } else {
         cat(important("  NOTE: Locus metrics recalculated\n"))
       }
       if (!mono.rm) {
         cat(important("  \nNOTE: Resultant monomorphic loci not deleted\n"))
       } else{
         cat(important("  NOTE: Resultant monomorphic loci deleted\n"))
         if (!recursive) {
           cat(warn("  Warning: Some individuals with a Call Rate initially >=",threshold,"may have a final CallRate lower than",threshold,"when call rate is recalculated after removing resultant monomorphic loci\n"))
           }
       }   
     }
   }
   
   # PRINTING OUTPUTS
   # using package patchwork
   p3 <- (p1/p2) 
   print(p3)

   # SAVE INTERMEDIATES TO TEMPDIR             
   # creating temp file names
   temp_plot <- tempfile(pattern =paste0("dartR_plot",paste0(names(match.call()),"_",as.character(match.call()),collapse = "_"),"_"))

   # saving to tempdir
   saveRDS(p3, file = temp_plot)
   if(verbose>=2){
     cat(report("  Saving the plot in ggplot format to the tempfile as",temp_plot,"using saveRDS\n"))
   }

   if(verbose>=2){
     cat(report("  NOTE: Retrieve output files from tempdir using gl.list.reports() and gl.print.reports()\n"))
   }

  # Recalculate Call Rate to be safe
      x <- utils.recalc.callrate(x,verbose=0)
      
# ADD TO HISTORY
      
   nh <- length(x2@other$history)
   x2@other$history[[nh + 1]] <- match.call()      
   
   # FLAG SCRIPT END
   
   if (verbose >= 1) {
     cat(report("\n\nCompleted:", funname, "\n\n"))
   }
   
   # RETURN

   return(x2)
 }
